<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Read data from GDX into R</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for rgdx {gdxrrw}"><tr><td>rgdx {gdxrrw}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Read data from GDX into R</h2>

<h3>Description</h3>

<p>Read one data item (also called a symbol) from GDX into R, returning
it as a list.  Note that GDX files contain multiple symbols (e.g. sets,
parameters).  Each symbol is read with a separate call.
</p>


<h3>Usage</h3>

<pre>
  # generic form - return a symbol as a list
  rgdx(gdxName, requestList = NULL, squeeze = TRUE, useDomInfo = TRUE,
       followAlias = TRUE)

  # return a set or parameter in a data frame
  rgdx.set(gdxName, symName, names=NULL, compress=FALSE, ts=FALSE,
           useDomInfo = TRUE, check.names = TRUE, te = FALSE)
  rgdx.param(gdxName, symName, names=NULL, compress=FALSE, ts=FALSE,
             squeeze=TRUE, useDomInfo = TRUE, check.names = TRUE)

  # return a scalar
  rgdx.scalar(gdxName, symName, ts=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>gdxName</code></td>
<td>
<p>the name of the GDX file to read</p>
</td></tr>
<tr valign="top"><td><code>requestList</code></td>
<td>
<p>the name of the symbol to read, and (optionally)
information about how much information to return and in what
format.  This argument must be a named list.  If omitted, the
universe of UELs contained in the GDX file is returned</p>
</td></tr>
<tr valign="top"><td><code>squeeze</code></td>
<td>
<p>if TRUE/nonzero, squeeze out any zero or EPS stored in the GDX container</p>
</td></tr>
<tr valign="top"><td><code>useDomInfo</code></td>
<td>
<p>if TRUE, the default filter will be the domain info
in the GDX.  If no domain info is available, or if
<code>useDomInfo=FALSE</code>, the default filter will be the GDX universe</p>
</td></tr>
<tr valign="top"><td><code>followAlias</code></td>
<td>
<p>if TRUE and the symbol queried is an alias,
return information for the real set rather than the alias</p>
</td></tr>
<tr valign="top"><td><code>check.names</code></td>
<td>
<p>If TRUE then the names of the variables in the data frame are checked to ensure that they are syntactically valid variable names and are not duplicated.  If necessary they are adjusted (by <code>make.names</code> so that they are</p>
</td></tr>
<tr valign="top"><td><code>symName</code></td>
<td>
<p>the name of the GDX symbol to read</p>
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
<p>the column names to use in the data frame returned</p>
</td></tr>
<tr valign="top"><td><code>compress</code></td>
<td>
<p>if TRUE, compress the factors in the data frame so they only include required levels.  For the default compress=FALSE, each factor includes levels for the entire universe of UELs in the GDX file</p>
</td></tr>
<tr valign="top"><td><code>ts</code></td>
<td>
<p>if TRUE, include the <code>.ts</code> field (i.e. the explanatory text) for the symbol in the return</p>
</td></tr>
<tr valign="top"><td><code>te</code></td>
<td>
<p>if TRUE, include the associated text (i.e. the <code>.te</code> field) for each set element in the return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>requestList</code> argument to <code>rgdx</code> is essentially a list
of arguments specifying what symbol to read and how to read it.  Valid
list elements are:
</p>

<dl>
<dt>name</dt><dd><p>name of symbol to read from GDX</p>
</dd>
<dt>form</dt><dd><p>specify representation to use on return: &ldquo;sparse&rdquo;
(default) or &ldquo;full&rdquo;</p>
</dd>
<dt>uels</dt><dd><p>UEL filter to use when reading</p>
</dd>
<dt>field</dt><dd><p>specify field to read for equations and variables</p>
</dd>
<dt>te</dt><dd><p>if true, return the associated text (i.e. the <code>.te</code>
field) for each set element in the return</p>
</dd>
<dt>ts</dt><dd><p>if true, include the explanatory text (i.e. the <code>.ts</code>
field) for the symbol in the return</p>
</dd>
<dt>compress</dt><dd><p>if true, compress UEL lists of return value by removing
unused elements in each index position</p>
</dd>
<dt>dim</dt><dd><p>expected dimension of symbol to be read</p>
</dd>
</dl>

<p>When reading sets, one can specify that the associated text is
included in the return value.  The value returned for set elements
where no associated text exists is controlled via the <code>options()</code>
mechanism.  Setting <code>options(gdx.inventSetText=NA)</code> (the default)
returns <code>NA</code>, setting <code>options(gdx.inventSetText=T)</code> returns
a string made up from the UEL(s), and setting
<code>options(gdx.inventSetText=F)</code> returns an empty string <code>""</code>.
</p>
<p>When reading GDX data into data frames (e.g. with <code>rgdx.param</code>),
the names() (i.e. the column names) of the output data frame can be
passed in via the optional <code>names</code> argument.  If not, then the names are
either created internally or taken from the domain information and
name of the symbol in question.  The latter choice is controlled by setting
<code>options(gdx.domainNames=FALSE)</code> to use internally generated
names for the data frame columns (e.g. <code>"i","j"</code> or
<code>"i1","i2","i3","i4"</code>).  A setting of TRUE (the default) means
use the domain names from the GDX file for the column names.
</p>


<h3>Value</h3>

<p>By default, the return value is a list with elements describing
the data item or symbol returned.  Elements include:
</p>

<dl>
<dt>name</dt><dd><p>symbol name</p>
</dd>
<dt>type</dt><dd><p>symbol's data type: <code>set</code>, <code>parameter</code>,
<code>variable</code> or <code>equation</code></p>
</dd>
<dt>dim</dt><dd><p>symbol dimension</p>
</dd>
<dt>val</dt><dd><p>array containing the symbol data</p>
</dd>
<dt>form</dt><dd><p>form of the data in <code>val</code>, i.e. <code>full</code> or
<code>sparse</code></p>
</dd>
<dt>uels</dt><dd><p>vector of UEL lists, one list per symbol dimension</p>
</dd>
<dt>domains</dt><dd><p>character vector of length <code>dim</code> containing the
symbol's domain info</p>
</dd>
<dt>te</dt><dd><p>(optional) associated text for sets</p>
</dd>
</dl>

<p>The functions <code>rgdx.param</code> and <code>rgdx.set</code> are
special-purpose wrappers that read parameters and sets,
respectively, and return them as data frames.
</p>
<p>The function <code>rgdx.scalar</code> returns a scalar (i.e. a
0-dimensional parameter) as a double.
</p>


<h3>Note</h3>

<p>A common problem is failure to load the external GDX libraries that
are required to interface with GDX data.  Use <code><a href="igdx.html">igdx</a></code> to
troubleshoot and solve this problem.
</p>


<h3>Author(s)</h3>

<p>Original coding by Rishabh Jain.  Adopted and packaged by
Steve Dirkse.  Maintainer: <a href="mailto:R@gams.com">R@gams.com</a></p>


<h3>See Also</h3>

<p><code><a href="igdx.html">igdx</a></code>, <code><a href="wgdx.html">wgdx</a></code>, <code><a href="gdxInfo.html">gdxInfo</a></code>
</p>


<h3>Examples</h3>

<pre>
  # run R-script trnsport.r from the data subdirectory of the gdxrrw package
  # to load up some data for writing to a GDX file
  data(trnsport)

  wgdx("rgdx1",sf,si,sj,sa,sb,sd)
  ou = rgdx("rgdx1")
  req &lt;- list(name="f")
  of = rgdx("rgdx1",req)
  req &lt;- list(name="i")
  oi = rgdx("rgdx1",req)
  req &lt;- list(name="j")
  oj = rgdx("rgdx1",req)
  req &lt;- list(name="a")
  oa = rgdx("rgdx1",req)
  req &lt;- list(name="b")
  ob = rgdx("rgdx1",req)
  req &lt;- list(name="d")
  od = rgdx("rgdx1",req)

  ## Not run: 
    # complete tests and examples can be run in the
    # extdata directory of the gdxrrw package
    # check .libPaths for a hint on where packages are installed
    setwd(paste(.libPaths()[1],"/gdxrrw/extdata",sep=""))
    source("tAll.R")
  
## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>gdxrrw</em> version 1.0.6 <a href="00Index.html">Index</a>]</div>
</body></html>
